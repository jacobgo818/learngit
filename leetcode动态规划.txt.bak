==========================================================
10. Regular Expression Matching


'.' Matches any single character.
'*' Matches zero or more of the preceding element.

The matching should cover the entire input string (not partial).

The function prototype should be:
bool isMatch(const char *s, const char *p)

Some examples:
isMatch("aa","a") → false
isMatch("aa","aa") → true
isMatch("aaa","aa") → false
isMatch("aa", "a*") → true
isMatch("aa", ".*") → true
isMatch("ab", ".*") → true
isMatch("aab", "c*a*b") → true
==========================================================
题意是：判断s能否为正则表达式p表示，其中，'.'表示一个任意字符；'*'表示可以出现任意个前移字符



/*
 * 不知道匹配机制是什么
 * ab .*居然也能通过
 */
public boolean isMatch(String s, String p) {
		if (s == null || p == null)
			return false;
		boolean[][] res = new boolean[s.length() + 1][p.length() + 1];
		res[0][0] = true;
		for (int i = 0; i < p.length(); i++) {
			if (p.charAt(i) == '*')
				res[0][i + 1] = res[0][i - 1];
		}

		for (int i = 0; i < s.length(); i++) {
			for (int j = 0; j < p.length(); j++) {
				if (p.charAt(j) == '.')
					res[i + 1][j + 1] = res[i][j];
				if (p.charAt(j) == s.charAt(i))
					res[i + 1][j + 1] = res[i][j];
				if (p.charAt(j) == '*') {
					if (p.charAt(j - 1) == '.' || p.charAt(j - 1) == s.charAt(i)) {
						res[i + 1][j + 1] = res[i + 1][j] || res[i + 1][j - 1] || res[i][j + 1];
					} else
						res[i + 1][j + 1] = res[i + 1][j - 1];
				}
			}
		}

		return res[s.length()][p.length()];
	}

==========================================================
32. Longest Valid Parentheses


Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.

For "(()", the longest valid parentheses substring is "()", which has length = 2.

Another example is ")()())", where the longest valid parentheses substring is "()()", which has length = 4.
==========================================================


题意：左右括号匹配

两种解法：1.用堆栈；2.用动态规划

/*
 * 非动态规划，有时候会超时
 */
public int longestValidParentheses(String s) {
	if (s == null || s.length() < 1)
		return 0;
	Stack<Integer> stack = new Stack<Integer>();
	int max = 0, left = -1;
	for (int i = 0; i < s.length(); i++) {
		if (s.charAt(i) == '(')
			stack.push(i);
		else {
			if (!stack.isEmpty()) {
				stack.pop();
				if (!stack.isEmpty())
					max = Math.max(max, i - stack.peek());
				else
					max = Math.max(max, i - left);
			} else
				left = i;
		}
	}
	return max;
}

/*
 * 动态规划
 */
public int longestValidParentheses1(String s) {
	int maxans = 0;
	int dp[] = new int[s.length()];
	for (int i = 1; i < s.length(); i++) {
		if (s.charAt(i) == ')') {
			if (s.charAt(i - 1) == '(') {
				dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;
			} else if (i - dp[i - 1] > 0 && s.charAt(i - dp[i - 1] - 1) == '(') {
				dp[i] = dp[i - 1] + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;
			}
			maxans = Math.max(maxans, dp[i]);
		}
	}
	return maxans;
}
// 测试
// Your runtime beats 92.48 % of java submissions.
public int longestValidParentheses2(String s) {
	if (s == null || s.length() == 0)
		return 0;
	int[] dp = new int[s.length()];
	int ans = 0;
	for (int i = 1; i < s.length(); i++) {
		// 如果是'('直接跳过，默认为0
		if (s.charAt(i) == ')') {
			if (s.charAt(i - 1) == '(')
				dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;
			// 说明s.charAt(i - 1)==')'
			else if (i - dp[i - 1] > 0 && s.charAt(i - dp[i - 1] - 1) == '(') {
				dp[i] = (i - dp[i - 1] > 1 ? dp[i - dp[i - 1] - 2] : 0) + dp[i - 1] + 2;
				// 因为加了一个左括号和一个右括号，所以是加2
			}
		}
		ans = Math.max(ans, dp[i]);
	}
	return ans;
}


==========================================================
44. Wildcard Matching
正则匹配：'?'任意字符 '*'任意序列或者空

'?' Matches any single character.
'*' Matches any sequence of characters (including the empty sequence).

The matching should cover the entire input string (not partial).

The function prototype should be:
bool isMatch(const char *s, const char *p)

Some examples:
isMatch("aa","a") → false
isMatch("aa","aa") → true
isMatch("aaa","aa") → false
isMatch("aa", "*") → true
isMatch("aa", "a*") → true
isMatch("ab", "?*") → true
isMatch("aab", "c*a*b") → false
==========================================================

/*
 * 二刷
 */
public boolean isMatch(String s, String p) {
	int row = s.length();
	int col = p.length();
	boolean[][] dp = new boolean[row + 1][col + 1];
	dp[0][0] = true;
	for (int j = 1; j < col + 1; j++) {
		if (dp[0][j - 1]) {
			if (p.charAt(j - 1) == '*')
				dp[0][j] = true;
			else
				break;
		}
	}
	for (int i = 0; i < row; i++)
		for (int j = 0; j < col; j++) {
			if (p.charAt(j) == s.charAt(i) || p.charAt(j) == '?')
				dp[i + 1][j + 1] = dp[i][j];
			else if (p.charAt(j) == '*') {
				dp[i + 1][j + 1] = dp[i][j] || dp[i + 1][j] || dp[i][j + 1];
			}
		}

	return dp[row][col];
}

/*
 * 一刷答案
 */
public boolean isMatch1(String s, String p) {
	boolean[][] match = new boolean[s.length() + 1][p.length() + 1];
	match[s.length()][p.length()] = true;
	for (int i = p.length() - 1; i >= 0; i--) {
		if (p.charAt(i) != '*')
			break;
		else
			match[s.length()][i] = true;
	}
	for (int i = s.length() - 1; i >= 0; i--) {
		for (int j = p.length() - 1; j >= 0; j--) {
			if (s.charAt(i) == p.charAt(j) || p.charAt(j) == '?')
				match[i][j] = match[i + 1][j + 1];
			else if (p.charAt(j) == '*')
				match[i][j] = match[i + 1][j] || match[i][j + 1];
			else
				match[i][j] = false;
		}
	}
	return match[0][0];
}

==========================================================
53. Maximum Subarray
简单题：就是求最大的子序列

Find the contiguous subarray within an array (containing at least one number) which has the largest sum.

For example, given the array [-2,1,-3,4,-1,2,1,-5,4],
the contiguous subarray [4,-1,2,1] has the largest sum = 6.

==========================================================

public int maxSubArray(int[] nums) {
	int maxEndingHere = 0;
	int maxSoFar = Integer.MIN_VALUE;
	for (int i = 0; i < nums.length; i++) {
		maxEndingHere += nums[i];
		if (maxEndingHere > maxSoFar)
			maxSoFar = maxEndingHere;
		if (maxEndingHere < 0)
			maxEndingHere = 0;
	}
	return maxSoFar;
}

==========================================================
62. Unique Paths

最简单的动态规划，一个矩阵，机器人初始位于左上角，每一格只能向右或者向下走
求到达右下角的所有路径和

A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

How many possible unique paths are there?


Above is a 3 x 7 grid. How many possible unique paths are there?

Note: m and n will be at most 100.
==========================================================

public int uniquePaths(int m, int n) {
	int[] dp = new int[n];
	Arrays.fill(dp, 1);

	for (int i = 1; i < m; i++) {
		for (int j = 1; j < n; j++) {
			dp[j]+=dp[j-1];
		}
	}
	return dp[n-1];
}


==========================================================
63. Unique Paths II

也是简单题：一个矩阵，机器人初始位于左上角，每一格只能向右或者向下走
求到达右下角的所有路径和，在矩阵中可能存在障碍。

Follow up for "Unique Paths":

Now consider if some obstacles are added to the grids. How many unique paths would there be?

An obstacle and empty space is marked as 1 and 0 respectively in the grid.

For example,
There is one obstacle in the middle of a 3x3 grid as illustrated below.

[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
The total number of unique paths is 2.

Note: m and n will be at most 100.
==========================================================

public int uniquePathsWithObstacles1(int[][] obstacleGrid) {
		if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0].length == 0)
			return 0;
		int m = obstacleGrid.length;
		int n = obstacleGrid[0].length;

		obstacleGrid[0][0] ^= 1;

		for (int i = 1; i < m; i++) {
			obstacleGrid[i][0] = obstacleGrid[i][0] == 1 ? 0 : obstacleGrid[i - 1][0];
		}

		for (int i = 1; i < n; i++) {
			obstacleGrid[0][i] = obstacleGrid[0][i] == 1 ? 0 : obstacleGrid[0][i - 1];
		}

		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				obstacleGrid[i][j] = obstacleGrid[i][j] == 1 ? 0 : obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];
			}
		}
		return obstacleGrid[m - 1][n - 1];
	}

==========================================================
64. Minimum Path Sum

从矩阵左上角到右下角，找到最小路径和


Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.

Note: You can only move either down or right at any point in time.

Example 1:
[[1,3,1],
 [1,5,1],
 [4,2,1]]
Given the above grid map, return 7. Because the path 1→3→1→1→1 minimizes the sum.
==========================================================

public int minPathSum(int[][] grid) {
	int row = grid.length;
	int col = grid[0].length;

	int[][] dp = new int[row][col];
	dp[0][0] = grid[0][0];

	for (int i = 1; i < row; i++) {
		dp[i][0] = dp[i - 1][0] + grid[i][0];
	}

	for (int j = 1; j < col; j++) {
		dp[0][j] = dp[0][j - 1] + grid[0][j];
	}

	for (int i = 1; i < row; i++)
		for (int j = 1; j < col; j++) {
			dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
		}

	return dp[row - 1][col - 1];
}

















